# c++ primer阅读记录

纯英文版的总共1300多页，阅读完需要比较长的时间，是一场马拉松，在此记录下一些自己并不清晰的知识点和有趣的东西

## 为什么要使用endl来进行刷新缓存区域

程序在调试过程中经常使用打印语句来输出一些信息，程序很有可能出现错误，输出有可能遗留在缓存区域，不及时清空的话，影响在下一次运行的输出，扰乱视听。
```c
#include <unistd.h>
#include <iostream>

int main()
{
    std::cout << "the normal one! " << std::endl;
    std::cout << "the test! ";
    sleep(20);
    std::cout << "the test is over" << std::endl;
    return 0;
}
```

## 注释的美学

两种注释，单行和多行注释，在使用ide的时候，注释代码块的时候直接使用单行注释的原因是：多行注释是无法进行嵌套的，单行则无所谓，虽然也可以强制进行多行注释，但最好不要这样使用。

## EOF

从键盘输入文件结束当我们从键盘输入程序时，不同的操作系统使用不同的约定来允许我们指示文件结束。在Windows系统上，我们通过键入control-z(按住Ctrl键并按z键)，然后按回车键或回车键来输入文件结尾。在UNIX系统上，包括在Mac OS X机器上，文件结尾通常是control-d。

## 动态语言和静态语言

一些语言，如python，在运行时检查类型。相比之下，C++是静态类型语言，类型检查在编译时完成。因此，编译器必须知道程序中使用的每个名字的类型

## 如何决定使用的数据的类型

- 当知道值不能为负数时，请使用无符号类型
- 整数运算使用int。short通常太小，实际上，long通常与int的大小相同。如果您的数据值大于int的最大范围，则使用long long
- 算术表达式中不要使用普通字符或布尔字符。仅用于描述字符或真实值。使用char的计算尤其有问题，因为char在一些机器上是有符号的，而在其他机器上是无符号的。如果需要微小的整数，请显式指定有符号字符或无符号字符
- 浮点计算使用double浮点运算通常没有足够的精度，并且双精度计算相对于单精度计算的成本可以忽略不计。事实上，在一些机器上，双精度操作比单精度操作更快。由长双精度提供的精度通常是不必要的，并且通常需要相当大的运行时间成本

总结：用int longlong double，知道没有负数用无符号，char和bool尽量不参与运算

## 字符串

彼此相邻且仅由空格，制表符或换行符分隔的两个字符串文字被串联为一个字符串，当我们需要写一个原本太大而无法舒适地放在一行上的文字时，我们使用这种形式

| meaning         | representation |
| --------------- | -------------- |
| newline         | \n             |
| horizontal tab  | \t             |
| alert(bell)     | \a             |
| vertical tab    | \v             |
| backspace       | \b             |
| double quote    | \"             |
| backslash       | \\             |
| question mark   | \?             |
| single quote    | \'             |
| carriage return | \r             |
| formfeed        | \f             |

## 初始化和赋值操作的区别

初始化不是赋值。初始化是在变量创建时为其赋值的。赋值操作用新值替换了该值。

## 列表初始化

可以确保初始化过程中的数据完整性，例如数据不会被截断而是直接报错。

## 声明和定义(declarations and definitions)

变量声明指定变量的类型和名称。变量定义是一个声明。除了指定名称和类型外，定义还分配存储空间，并可以为变量提供初始值。变量多文件共享，一个地方定义，多个地方声明。

```c
// *.h
extern int a; //声明，并没有占用实际内存，开辟新对象

// *.cpp
int a = 100; // 定义
int b; //实际上也是定义了object
extern int a = 100; // 定义，赋值了，成为新的object
// 调用
#include "*.h"
cout << a;
```

## 常量指针，指针常量

```c
//一般形式，从右往左解释
const int *a; // 指向常量的指针，指针内容可变，指向的内容不可变
int *const a; // 指针常量，指向int，指针内容不可变，指向的内容可变

// 特殊形式
typedef char *pstring // pstring是个字符指针
const pstring s; // 是一个指针常量，同上面第二种情况

```

## 预处理变量 头文件保护

预处理变量是为了防止头文件在重复调用的过程中多次定义同一个class，例如A.h被B.h include，然后main.cpp include A.h, B.h。
第一次直接从A.h遇到#ifndef A，执行#define A，之后遇到B.h间接的include A.h，相当于第二次遇到#ifdef A，判断结果是假，就不会继续执行#define 以及后面的定义。都采用大写是为了避免和其他实体发生冲突。

## range for

- 该操作只适用于处理整个序列，使用range for的时候遇到需要直接改变对应元素的时候应当使用应用处理，for(auto &c: string1) {}
- 使用下标运算符[]实际上返回的就是一个引用
- 范围for使用的过程中不能更改它所迭代的序列的size

## 逻辑比较符

&& 只有左侧运算数为真才计算右侧，通常还有下标的操作放在后侧，左侧先对下标的范围进行合法性检查

## 迭代器

所有的库容器都有迭代器，但不一定都有能使用下标进行访问
为了简化迭代器的使用，*it有歧义，直接使用->来调用解引用的对象
当插入删除迭代对象当时候，地址空间会发生变化，导致迭代器失效

## constexpr

编译时就能够计算得到结果的，可以用array进行检验

